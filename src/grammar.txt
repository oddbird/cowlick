tag
  = statement_tag / expression_tag / comment_tag

statement_tag
  = '{%' ws? block:(if / elif / else / endif / for / endfor / macro / endmacro) ws? '%}' {
    return block;
  }

if
  = 'if' ws expression:expression {
    return {
      node: 'if',
      condition: expression,
      block: [],
      else: null
    }
  }
elif
  = 'elif' ws expression:expression {
    return {
      node: 'elif',
      condition: expression,
      block: [],
      else: null
    };
  }
else
  = 'else' {
    return {
      node: 'else',
      block: []
    };
  }
endif
  = 'endif' {
    return {
      node: 'endif'
    };
  }

for
  = 'for' ws loopvar:identifier ws 'in' ws expression:expression {
    return {
      node: 'for',
      loopvar: loopvar,
      range: expression,
      block: []
    };
  }
endfor
  = 'endfor' {
    return {
      node: 'endfor'
    };
  }

macro
  = 'macro' ws name:identifier ws? '(' ws? args:arglist? ws? ')' {
    return {
      node: 'macro',
      name: name,
      args: args,
      block: []
    };
  }
endmacro
  = 'endmacro' {
    return {
      node: 'endmacro',
    };
  }
arglist
  = head:arg tail:(',' ws? arg)* {
    return [head].concat(tail.map(function (tail) {
      return tail[2];
    }));
  }
arg
  = name:identifier default_val:(ws? '=' ws? literal)? {
    return {
      name: name,
      default: default_val ? default_val[3] : undefined
    };
  }

expression_tag
  = '{{' ws? expression:expression ws? '}}' {
    return {
      node: 'expression',
      body: expression
    };
  }

expression
  = term:term operation:postfix_operation? {
    if (operation) {
      operation.base = term;
      return operation;
    } else {
      return term;
    }
  }

parenthesized_expression
  = '(' ws? expression:expression ws? ')' {
    return expression;
  }

term
  = literal / variable / parenthesized_expression

postfix_operation
  = getattr / getitem / call

getattr
  = '.' name:identifier {
    return {
      node: 'getattr',
      name: name
    }
  }

getitem
  = '[' name:expression ']' {
    return {
      node: 'getitem',
      name: name
    }
  }

call
  = '(' args:callargs ')' {
    return {
      node: 'call',
      args: args
    };
  }
callargs
  = head:callarg tail:(',' ws? callarg)* {
    return [head].concat(tail.map(function (tail) {
      return tail[2];
    }));
  }
callarg
  = name:(identifier '=')? expression:expression {
    var node = { value: expression };
    if (name) node.name = name[0];
    return node;
  }

literal
  = boolean / string / float

boolean
  = value:('True' / 'False' / 'true' / 'false') {
    return {
      node: 'boolean',
      value: (value.toLowerCase() == 'true')
    };
  }

string
  = sq_string / dq_string

dq_string
  = '"' value:([^"]+) '"' {
    return {
      node: 'text',
      value: value.join('')
    };
  }

sq_string
  = "'" value:([^']+) "'" {
    return {
      node: 'text',
      value: value.join('')
    };
  }

float
  = value:([0-9.]+) {
    return {
      node: 'float',
      value: parseFloat(value.join(''))
    };
  }

variable
  = name:identifier {
    return {
      node: 'variable',
      name: name
    }
  }

identifier
  = name:([a-zA-Z][a-zA-Z0-9_]*) {
    return name[0] + name[1].join('');
  }

ws
  = [\n ]+

comment_tag
  = '{#' ws? comment:(!(ws? '#}') .)* ws? '#}' {
    return {
      node: 'comment',
      value: comment.map(function(x) { return x[1]; }).join('')
    }
  }
